# 1. 기본형 vs 참조형 - 시작

## 기본형(Primitive Type)과 참조형(Reference Type)

자바에서 변수의 타입은 크게 두 가지로 나눌 수 있음.

### 기본형 (Primitive Type)

* `int`, `long`, `double`, `boolean` 등
* **실제 값을 변수에 직접 저장**
* 예:

  ```java
  int a = 10;
  ```

  → 변수 `a`에 숫자 10이 직접 들어 있음.

### 참조형 (Reference Type)

* 배열(`int[]`), 클래스(`Student`) 등
* **실제 데이터가 저장된 메모리 주소(참조값)를 변수에 저장**
* 예:

  ```java
  Student student1 = new Student();
  ```

  → `student1` 변수 안에는 Student 객체가 있는 위치(메모리 주소)가 들어 있음.

쉽게 말해,

| 타입  | 변수 안에 저장되는 값     |
|-----|------------------|
| 기본형 | 실제 사용 값          |
| 참조형 | 객체/배열이 있는 메모리 주소 |

---

## 기본형 vs 참조형 - 기본적인 차이

### 기본형은 값을 직접 사용

```java
int a = 10;
int b = 20;
int sum = a + b; // 바로 계산 가능
```

### 참조형은 주소만 가지고는 아무것도 못함

```java
Student s1 = new Student();
Student s2 = new Student();
s1 +s2;  // 오류 발생
```

참조형은 **주소값 자체로는 연산 불가능**하기 때문임.

### 하지만 객체 내부의 기본형 값에는 접근 가능

```java
s1.grade =100;
s2.grade =90;
int sum = s1.grade + s2.grade; // 가능
```

`.`(dot)을 통해 실제 값이 있는 메모리로 이동해 접근한다는 개념임.

---

## 기본형 vs 참조형 - 연산 가능 여부

| 타입          | 연산 가능 여부 | 이유                  |
|-------------|----------|---------------------|
| 기본형         | 가능       | 값 자체가 변수에 있음        |
| 참조형         | 불가능      | 참조값(주소)이라 계산 불가     |
| 참조형 내부의 기본형 | 가능       | "."을 통해 실제 값에 접근 가능 |

참조형은 “주소지”일 뿐이고, “집 안에 있는 물건(실제 값)”에 접근해야 계산이 가능하다는 비유가 잘 맞음.

---

## 쉽게 정리하는 팁

* **기본형을 제외한 모든 타입은 전부 참조형임.**
* **기본형은 모두 소문자로 시작함 → int, long, boolean 등**
* **개발자가 새롭게 만들 수 있는 타입은 모두 참조형(클래스)임**

    * 클래스는 항상 대문자로 시작 → `Student`, `StringBuilder` 등
* **참조형은 배열도 포함됨**

---

## 참고: String은 사실 “참조형”임

`String`은 클래스이기 때문에 참조형임.

하지만 아래처럼 “값을 직접 넣는 것처럼” 사용할 수 있음:

```java
String name = "홍길동";
```

문자열은 너무 자주 쓰여서 자바가 특별한 문법적 편의를 제공하기 때문임.
자세한 내용은 String 챕터에서 다룸.

---

# 2. 기본형 vs 참조형 - 변수 대입

## 자바의 변수 대입 대원칙

### 변수 대입 = 변수 안의 값을 복사하는 것

* **기본형(Primitive Type)** → 값 자체(숫자 등)를 복사
* **참조형(Reference Type)** → 객체의 주소(참조값)를 복사

즉, “변수에 무엇이 들어있던지 그대로 복사한다”는 것이 핵심임.

---

## 기본형의 변수 대입

### 코드 예시

```java
int a = 10;
int b = a;
```

### 설명

* `a`에는 값 10이 저장됨
* `b = a`는 **10이라는 값만 복사**한 것임
* `b`가 변경되어도 `a`에 영향 없음

### 예제 출력

```
a = 10
b = 10
변경 a = 20
a = 20
b = 10
변경 b = 30
a = 20
b = 30
```

### 핵심

* 기본형은 **각자 독립된 값을 가짐**
* 대입하는 순간 값 자체가 복사되기 때문에 이후에 서로 영향 없음

---

## 참조형의 변수 대입

### Data 클래스

```java
public class Data {
    int value;
}
```

### 예제 코드

```java
Data dataA = new Data();
dataA.value =10;

Data dataB = dataA;
```

### 중요한 포인트

* `dataA`에는 **객체의 참조값(x001 등)** 이 저장됨
* `dataB = dataA`는 **참조값 x001을 복사**한 것임
* 객체 자체를 복사한 것이 아님!

### 실행 결과

```
dataA 참조값=ref.Data@x001
dataB 참조값=ref.Data@x001
dataA.value = 10
dataB.value = 10
```

### dataA.value 변경

```java
dataA.value =20;
```

```
dataA.value = 20
dataB.value = 20
```

### dataB.value 변경

```java
dataB.value =30;
```

```
dataA.value = 30
dataB.value = 30
```

### 핵심 이유

* dataA, dataB는 **같은 객체(x001)를 가리킴**
* 참조값을 그대로 복사했기 때문
* 어떤 변수로 접근하든 결국 같은 객체의 값을 변경하게 됨

---

## 핵심 정리

### 기본형 대입

* 값 자체를 복사
* 서로 완전히 독립

### 참조형 대입

* **주소(참조값)를 복사**
* 두 변수가 **같은 객체를 공유**
* 한 변수가 값을 변경하면 다른 변수에도 반영됨

---

## 시각적으로 이해하기

### 기본형

```
a → 10
b → 10 (복사된 값)
```

### 참조형

```
dataA → x001 → Data 객체(value=10)
dataB → x001 → Data 객체(value=10)
```

# 3. 기본형 vs 참조형 - 메서드 호출

### 대원칙: 자바는 항상 "변수에 들어 있는 값"을 복사해서 전달한다.

메서드 호출 시 전달되는 매개변수 역시 **변수**이므로
"값 복사 → 전달" 원칙이 그대로 적용됨.

문제는 이 “값(value)”이

* 기본형이면 **실제 숫자값**이고
* 참조형이면 **객체 주소값(참조값)** 이라는 점임.

이 차이 때문에 메서드 호출 결과가 완전히 달라짐.

---

## 기본형과 메서드 호출

### 코드

```java
public class MethodChange1 {
    public static void main(String[] args) {
        int a = 10;
        System.out.println("메서드 호출 전: a = " + a);
        changePrimitive(a);
        System.out.println("메서드 호출 후: a = " + a);
    }

    static void changePrimitive(int x) {
        x = 20;
    }
}
```

### 실행 결과

```
메서드 호출 전: a = 10
메서드 호출 후: a = 10
```

---

### 왜 바뀌지 않을까?

1. 메서드 호출

```java
int x = a; // 값 10을 복사해서 전달
```

```
a → 10
x → 10 (복사본)
```

2. 메서드 내부 변경

```java
x =20; // 복사본만 변경
```

3. 메서드 종료 후
   `x`는 사라지고, 원래 변수 `a`는 그대로 10 유지됨.

---

## 참조형과 메서드 호출

### 코드

```java
public class MethodChange2 {
    public static void main(String[] args) {
        Data dataA = new Data();
        dataA.value = 10;

        System.out.println("메서드 호출 전: dataA.value = " + dataA.value);
        changeReference(dataA);
        System.out.println("메서드 호출 후: dataA.value = " + dataA.value);
    }

    static void changeReference(Data dataX) {
        dataX.value = 20;
    }
}
```

### 실행 결과

```
메서드 호출 전: dataA.value = 10
메서드 호출 후: dataA.value = 20
```

---

### 왜 값이 변경되었을까?

1. 메서드 호출

```java
Data dataX = dataA; // 참조값(x001)을 복사해서 전달
```

```
dataA → x001 → Data(value=10)
dataX → x001 → Data(value=10)
```

둘 다 같은 객체를 가리킴.

2. 메서드 내부에서 x001 객체의 value가 10 → 20 으로 변경

```java
dataX.value =20;
```

3. 메서드 종료 후에도 동일한 객체를 계속 바라보기 때문에 20으로 변경

```
dataA.value → 20
```

---

## 기본형 vs 참조형 메서드 호출 요약

| 종류  | 전달되는 값     | 메서드 내부 변경 결과 |
|-----|------------|--------------|
| 기본형 | 실제 값       | 원본 변수 영향 없음  |
| 참조형 | 객체 주소(참조값) | 객체 내부 값 변경됨  |

---

## 핵심 포인트

* 자바는 **항상 값 복사(pass-by-value)** 방식만 사용함
* 참조형이 메서드 내부에서 변경되는 이유는
  “객체를 복사한 것”이 아니라 **주소값을 복사했기 때문**
* 주소값이 같으면 같은 객체를 바라보므로
  → 내부 값을 바꾸면 원본도 바뀜

