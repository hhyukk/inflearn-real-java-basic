# 1. 기본형 vs 참조형 - 시작

## 기본형(Primitive Type)과 참조형(Reference Type)

자바에서 변수의 타입은 크게 두 가지로 나눌 수 있음.

### 기본형 (Primitive Type)

* `int`, `long`, `double`, `boolean` 등
* **실제 값을 변수에 직접 저장**
* 예:

  ```java
  int a = 10;
  ```

  → 변수 `a`에 숫자 10이 직접 들어 있음.

### 참조형 (Reference Type)

* 배열(`int[]`), 클래스(`Student`) 등
* **실제 데이터가 저장된 메모리 주소(참조값)를 변수에 저장**
* 예:

  ```java
  Student student1 = new Student();
  ```

  → `student1` 변수 안에는 Student 객체가 있는 위치(메모리 주소)가 들어 있음.

쉽게 말해,

| 타입  | 변수 안에 저장되는 값     |
|-----|------------------|
| 기본형 | 실제 사용 값          |
| 참조형 | 객체/배열이 있는 메모리 주소 |

---

## 기본형 vs 참조형 - 기본적인 차이

### 기본형은 값을 직접 사용

```java
int a = 10;
int b = 20;
int sum = a + b; // 바로 계산 가능
```

### 참조형은 주소만 가지고는 아무것도 못함

```java
Student s1 = new Student();
Student s2 = new Student();
s1 +s2;  // 오류 발생
```

참조형은 **주소값 자체로는 연산 불가능**하기 때문임.

### 하지만 객체 내부의 기본형 값에는 접근 가능

```java
s1.grade =100;
s2.grade =90;
int sum = s1.grade + s2.grade; // 가능
```

`.`(dot)을 통해 실제 값이 있는 메모리로 이동해 접근한다는 개념임.

---

## 기본형 vs 참조형 - 연산 가능 여부

| 타입          | 연산 가능 여부 | 이유                  |
|-------------|----------|---------------------|
| 기본형         | 가능       | 값 자체가 변수에 있음        |
| 참조형         | 불가능      | 참조값(주소)이라 계산 불가     |
| 참조형 내부의 기본형 | 가능       | "."을 통해 실제 값에 접근 가능 |

참조형은 “주소지”일 뿐이고, “집 안에 있는 물건(실제 값)”에 접근해야 계산이 가능하다는 비유가 잘 맞음.

---

## 쉽게 정리하는 팁

* **기본형을 제외한 모든 타입은 전부 참조형임.**
* **기본형은 모두 소문자로 시작함 → int, long, boolean 등**
* **개발자가 새롭게 만들 수 있는 타입은 모두 참조형(클래스)임**

    * 클래스는 항상 대문자로 시작 → `Student`, `StringBuilder` 등
* **참조형은 배열도 포함됨**

---

## 참고: String은 사실 “참조형”임

`String`은 클래스이기 때문에 참조형임.

하지만 아래처럼 “값을 직접 넣는 것처럼” 사용할 수 있음:

```java
String name = "홍길동";
```

문자열은 너무 자주 쓰여서 자바가 특별한 문법적 편의를 제공하기 때문임.
자세한 내용은 String 챕터에서 다룸.

---

# 2. 기본형 vs 참조형 - 변수 대입

## 자바의 변수 대입 대원칙

### 변수 대입 = 변수 안의 값을 복사하는 것

* **기본형(Primitive Type)** → 값 자체(숫자 등)를 복사
* **참조형(Reference Type)** → 객체의 주소(참조값)를 복사

즉, “변수에 무엇이 들어있던지 그대로 복사한다”는 것이 핵심임.

---

## 기본형의 변수 대입

### 코드 예시

```java
int a = 10;
int b = a;
```

### 설명

* `a`에는 값 10이 저장됨
* `b = a`는 **10이라는 값만 복사**한 것임
* `b`가 변경되어도 `a`에 영향 없음

### 예제 출력

```
a = 10
b = 10
변경 a = 20
a = 20
b = 10
변경 b = 30
a = 20
b = 30
```

### 핵심

* 기본형은 **각자 독립된 값을 가짐**
* 대입하는 순간 값 자체가 복사되기 때문에 이후에 서로 영향 없음

---

## 참조형의 변수 대입

### Data 클래스

```java
public class Data {
    int value;
}
```

### 예제 코드

```java
Data dataA = new Data();
dataA.value =10;

Data dataB = dataA;
```

### 중요한 포인트

* `dataA`에는 **객체의 참조값(x001 등)** 이 저장됨
* `dataB = dataA`는 **참조값 x001을 복사**한 것임
* 객체 자체를 복사한 것이 아님!

### 실행 결과

```
dataA 참조값=ref.Data@x001
dataB 참조값=ref.Data@x001
dataA.value = 10
dataB.value = 10
```

### dataA.value 변경

```java
dataA.value =20;
```

```
dataA.value = 20
dataB.value = 20
```

### dataB.value 변경

```java
dataB.value =30;
```

```
dataA.value = 30
dataB.value = 30
```

### 핵심 이유

* dataA, dataB는 **같은 객체(x001)를 가리킴**
* 참조값을 그대로 복사했기 때문
* 어떤 변수로 접근하든 결국 같은 객체의 값을 변경하게 됨

---

## 핵심 정리

### 기본형 대입

* 값 자체를 복사
* 서로 완전히 독립

### 참조형 대입

* **주소(참조값)를 복사**
* 두 변수가 **같은 객체를 공유**
* 한 변수가 값을 변경하면 다른 변수에도 반영됨

---

## 시각적으로 이해하기

### 기본형

```
a → 10
b → 10 (복사된 값)
```

### 참조형

```
dataA → x001 → Data 객체(value=10)
dataB → x001 → Data 객체(value=10)
```

# 3. 기본형 vs 참조형 - 메서드 호출

### 대원칙: 자바는 항상 "변수에 들어 있는 값"을 복사해서 전달한다.

메서드 호출 시 전달되는 매개변수 역시 **변수**이므로
"값 복사 → 전달" 원칙이 그대로 적용됨.

문제는 이 “값(value)”이

* 기본형이면 **실제 숫자값**이고
* 참조형이면 **객체 주소값(참조값)** 이라는 점임.

이 차이 때문에 메서드 호출 결과가 완전히 달라짐.

---

## 기본형과 메서드 호출

### 코드

```java
public class MethodChange1 {
    public static void main(String[] args) {
        int a = 10;
        System.out.println("메서드 호출 전: a = " + a);
        changePrimitive(a);
        System.out.println("메서드 호출 후: a = " + a);
    }

    static void changePrimitive(int x) {
        x = 20;
    }
}
```

### 실행 결과

```
메서드 호출 전: a = 10
메서드 호출 후: a = 10
```

---

### 왜 바뀌지 않을까?

1. 메서드 호출

```java
int x = a; // 값 10을 복사해서 전달
```

```
a → 10
x → 10 (복사본)
```

2. 메서드 내부 변경

```java
x =20; // 복사본만 변경
```

3. 메서드 종료 후
   `x`는 사라지고, 원래 변수 `a`는 그대로 10 유지됨.

---

## 참조형과 메서드 호출

### 코드

```java
public class MethodChange2 {
    public static void main(String[] args) {
        Data dataA = new Data();
        dataA.value = 10;

        System.out.println("메서드 호출 전: dataA.value = " + dataA.value);
        changeReference(dataA);
        System.out.println("메서드 호출 후: dataA.value = " + dataA.value);
    }

    static void changeReference(Data dataX) {
        dataX.value = 20;
    }
}
```

### 실행 결과

```
메서드 호출 전: dataA.value = 10
메서드 호출 후: dataA.value = 20
```

---

### 왜 값이 변경되었을까?

1. 메서드 호출

```java
Data dataX = dataA; // 참조값(x001)을 복사해서 전달
```

```
dataA → x001 → Data(value=10)
dataX → x001 → Data(value=10)
```

둘 다 같은 객체를 가리킴.

2. 메서드 내부에서 x001 객체의 value가 10 → 20 으로 변경

```java
dataX.value =20;
```

3. 메서드 종료 후에도 동일한 객체를 계속 바라보기 때문에 20으로 변경

```
dataA.value → 20
```

---

## 기본형 vs 참조형 메서드 호출 요약

| 종류  | 전달되는 값     | 메서드 내부 변경 결과 |
|-----|------------|--------------|
| 기본형 | 실제 값       | 원본 변수 영향 없음  |
| 참조형 | 객체 주소(참조값) | 객체 내부 값 변경됨  |

---

## 핵심 포인트

* 자바는 **항상 값 복사(pass-by-value)** 방식만 사용함
* 참조형이 메서드 내부에서 변경되는 이유는
  “객체를 복사한 것”이 아니라 **주소값을 복사했기 때문**
* 주소값이 같으면 같은 객체를 바라보므로
  → 내부 값을 바꾸면 원본도 바뀜

# 4. 참조형과 메서드 호출 - 활용

## 중복되는 코드 확인하기

초기 예제(ClassStart3)에서는 같은 작업이 반복됨:

1. 학생 객체 생성 후 `name`, `age`, `grade` 설정
2. 학생 정보 출력

```java
Student student1 = new Student();
student1.name ="학생1";
student1.age =15;
student1.grade =90;

Student student2 = new Student();
student2.name ="학생2";
student2.age =16;
student2.grade =80;

        System.out.

println(...);
System.out.

println(...);
```

이런 반복 작업은 메서드로 충분히 정리할 수 있음.

---

## 참조형을 메서드로 전달하기

### Student 클래스

```java
public class Student {
    String name;
    int age;
    int grade;
}
```

### 메서드로 중복 제거한 코드(Method1)

```java
public class Method1 {
    public static void main(String[] args) {
        Student student1 = new Student();
        initStudent(student1, "학생1", 15, 90);

        Student student2 = new Student();
        initStudent(student2, "학생2", 16, 80);

        printStudent(student1);
        printStudent(student2);
    }

    static void initStudent(Student student, String name, int age, int grade) {
        student.name = name;
        student.age = age;
        student.grade = grade;
    }

    static void printStudent(Student student) {
        System.out.println("이름:" + student.name + " 나이:" + student.age + " 성적:" + student.grade);
    }
}
```

---

## 참조형을 메서드에 전달하면?

`initStudent(student1, …)` 호출 시 전달되는 값은 “객체 주소값(참조값)”임.

```
Student student1 → x001 (Student 객체)
initStudent(student1) → initStudent(x001)
```

메서드의 매개변수 `student`가 받는 것도 x001
→ 결국 **같은 Student 객체를 공유하며 수정 가능**함.

이를 통해:

* 메서드 안에서 객체의 값을 변경할 수 있고,
* 코드 중복도 줄일 수 있음.

---

## 객체 생성 + 초기화까지 묶어서 반환하기

이제 다음 중복도 제거 가능함:

```java
Student student1 = new Student();

initStudent(student1, ...);

Student student2 = new Student();

initStudent(student2, ...);
```

이를 하나의 메서드로 합침.

---

## 객체를 생성하여 반환하는 방식(Method2)

```java
public class Method2 {
    public static void main(String[] args) {
        Student student1 = createStudent("학생1", 15, 90);
        Student student2 = createStudent("학생2", 16, 80);

        printStudent(student1);
        printStudent(student2);
    }

    static Student createStudent(String name, int age, int grade) {
        Student student = new Student();
        student.name = name;
        student.age = age;
        student.grade = grade;
        return student; // 객체 주소값 반환
    }

    static void printStudent(Student student) {
        System.out.println("이름:" + student.name + " 나이:" + student.age + " 성적:" + student.grade);
    }
}
```

---

## createStudent() 동작 방식 이해하기

```
Student student1 = createStudent("학생1", 15, 90);
```

1. 메서드 내부에서 `new Student()`로 학생 객체 생성 (예: x001)
2. name, age, grade 초기화
3. `return student` → 즉, `return x001`
4. 결국 호출한 곳에서

   ```
   student1 = x001
   ```

이렇게 학생 객체를 한 번에 생성 + 초기화 + 반환할 수 있음.

# 5. 변수와 초기화

## 변수의 종류

자바 변수는 크게 두 가지로 나뉨.

### 멤버 변수(필드)

* 클래스 내부에 선언된 변수
* 인스턴스가 생성될 때 함께 만들어짐
* 인스턴스가 사라질 때 함께 제거됨
* 객체의 속성을 저장하는 역할을 함

예시:

```java
public class Student {
    String name;
    int age;
    int grade;
}
```

여기서 `name`, `age`, `grade`는 모두 **멤버 변수**임.

---

### 지역 변수(Local Variable)

* 메서드 내부에서 선언되는 변수
* 메서드가 실행될 때 생성되고, 메서드 종료 시 사라짐
* 매개변수(parameter)도 지역 변수의 한 종류

예시:

```java
public class ClassStart3 {
    public static void main(String[] args) {
        Student student1;
        student1 = new Student();
        Student student2 = new Student();
    }
}
```

`student1`, `student2`는 지역 변수임.

또 다른 예시:

```java
public class MethodChange1 {
    public static void main(String[] args) {
        int a = 10;
        changePrimitive(a);
    }

    public static void changePrimitive(int x) {
        x = 20;
    }
}
```

여기서 `a`, `x` 모두 **지역 변수**임.

지역 변수는 "해당 메서드 블록 안"에서만 사용 가능하며, 메서드가 끝나면 사라짐.

---

## 변수의 값 초기화

자바에서 중요한 차이:

| 변수 종류         | 초기화 방식     | 설명                    |
|---------------|------------|-----------------------|
| **멤버 변수(필드)** | **자동 초기화** | 객체 생성 시 자바가 기본값으로 초기화 |
| **지역 변수**     | **수동 초기화** | 개발자가 직접 값을 넣어야 함      |

---

### 멤버 변수(필드)는 자동 초기화됨

기본값은 다음과 같음:

| 타입            | 기본 초기값 |
|---------------|--------|
| int           | 0      |
| double        | 0.0    |
| boolean       | false  |
| 참조형(Object 등) | null   |

예제:

```java
public class InitData {
    int value1;      // 초기화 안 함 → 자동 초기화: 0
    int value2 = 10; // 명시적 초기화
}
```

테스트 코드:

```java
public class InitMain {
    public static void main(String[] args) {
        InitData data = new InitData();
        System.out.println("value1 = " + data.value1);
        System.out.println("value2 = " + data.value2);
    }
}
```

출력:

```
value1 = 0
value2 = 10
```

---

### 지역 변수는 반드시 수동 초기화해야 함

지역 변수는 **초기화를 하지 않으면 사용 불가**
컴파일 오류가 발생함.

예:

```java
int a;
System.out.

println(a); // 오류!
```

지역 변수는 메모리에 생성될 때 **기본값이 없음** → 직접 값을 넣어야 함.

---

## 정리

### 멤버 변수(필드)

* 객체 생성 시 함께 생성
* 자동 초기화
* 객체 영역에서 넓게 사용됨

### 지역 변수

* 메서드 실행 시 생성 → 종료 시 제거
* 절대 자동 초기화되지 않음
* 반드시 개발자가 값을 직접 넣어야 함

---

# 6. null

## null이란?

* 참조형 변수에 저장되는 것은 **객체의 주소값(참조값)**
* 하지만 아직 객체를 생성하지 않았거나, 나중에 연결하고 싶을 때는?
  → **null을 넣어서 비워둘 수 있음**

즉, null은 **참조할 대상이 없음**을 의미하는 특별한 값임.

---

## null 값 할당 예시

### Data 클래스

```java
public class Data {
    int value;
}
```

### null 사용 예제

```java
public class NullMain1 {
    public static void main(String[] args) {
        Data data = null;
        System.out.println("1. data = " + data);

        data = new Data();
        System.out.println("2. data = " + data);

        data = null;
        System.out.println("3. data = " + data);
    }
}
```

### 실행 결과

```
1. data = null
2. data = ref.Data@x001
3. data = null
```

---

## 실행 과정 설명

### 1. `Data data = null;`

* Data 타입의 참조형 변수 `data` 선언
* 하지만 아직 아무 객체도 가리키지 않음
  → `data`는 `null`

### 2. `data = new Data();`

* 새로운 Data 객체를 생성
* 생성된 객체의 참조값(예: x001)을 `data`에 저장
* 이제 `data`는 실제 객체를 가리키는 상태

### 3. `data = null;`

* 다시 `null`을 넣으면
  → data는 더 이상 x001 객체를 가리키지 않음
* 참조가 끊김

---

## 아무도 참조하지 않는 객체의 최후: GC(가비지 컬렉션)

data가 다시 null이 되면,

```
data → null
x001 객체 → 아무도 참조하지 않음
```

그러면 어떻게 될까?

### 과거 언어(C 등)

* 개발자가 직접 객체 삭제 작업을 수행해야 했음
* 실수로 삭제하지 않으면 메모리에 쌓여 “메모리 부족 오류” 발생

### 자바의 방식

자바는 **GC(가비지 컬렉터)**가 자동으로 처리함.

* 더 이상 어떤 변수도 참조하지 않는 객체를 찾아내 제거
* 개발자가 직접 삭제할 필요 없음
* 메모리 누수 위험 감소

### 핵심 원리

* 객체는 **누군가 참조하고 있으면 살아 있음**
* 모든 참조가 사라지는 순간 → GC 후보가 됨
* GC가 적절한 시점에 해당 객체를 메모리에서 제거

---

## 정리

* null은 “아무 객체도 참조하지 않음”을 의미하는 특별한 값
* 참조형 변수는 언제든 null을 넣어 비울 수 있음
* null을 넣으면 이전에 참조하던 객체와의 연결이 끊김
* 아무도 참조하지 않는 객체는 GC가 자동으로 메모리에서 제거함

---

# 7. NullPointerException

자바 개발자라면 평생 가장 많이 만나게 되는 예외가 바로 **NullPointerException(NPE)**임.
NPE는 “null을 가리키는(Pointer) 순간 발생하는 Exception”이라는 의미 그대로,
**null에 .(dot)을 찍어서 존재하지 않는 객체에 접근하려고 할 때** 발생함.

택배 비유로 보면, **배송 주소지가 없는데 택배를 보내려는 상황**과 완전히 같음.
“어디로 가야 할지 모르는” 상태이기 때문에 예외가 터짐.

---

## NullPointerException이 발생하는 이유

참조형 변수는 객체의 **주소값**을 저장함.
그런데 null은 “아무것도 없음”이라는 뜻. 즉:

```
data = null;
data.value = 10;   // null.value → 주소지가 없으므로 접근 불가!
```

이때 프로그램은 즉시 NPE를 던지고 종료됨.

---

## 간단한 예제로 확인해보기

### Data 클래스

```java
public class Data {
    int value;
}
```

### NPE 발생 코드

```java
public class NullMain2 {
    public static void main(String[] args) {
        Data data = null;
        data.value = 10; // NullPointerException 발생
        System.out.println(data.value);
    }
}
```

### 실행 결과

```
Exception in thread "main" java.lang.NullPointerException:
Cannot assign field "value" because "data" is null
```

> null에 .(dot)을 찍으면 무조건 NullPointerException 발생함.

---

## 멤버 변수에서의 null 주의!

지역 변수에서는 null 여부를 비교적 쉽게 확인할 수 있지만,
**멤버 변수는 자동 초기화되기 때문에 null 문제를 발견하기 어려울 수 있음.**

### BigData 클래스

```java
public class BigData {
    Data data; // 자동 초기화 → null
    int count; // 자동 초기화 → 0
}
```

### NullPointerException 발생 예제

```java
public class NullMain3 {
    public static void main(String[] args) {
        BigData bigData = new BigData();

        System.out.println("bigData.count=" + bigData.count); // 0
        System.out.println("bigData.data=" + bigData.data);   // null

        // NullPointerException 발생!
        System.out.println("bigData.data.value=" + bigData.data.value);
    }
}
```

### 실행 결과

```
bigData.count=0
bigData.data=null
Exception in thread "main" java.lang.NullPointerException
```

### 왜 발생했을까?

```
bigData.data → null
bigData.data.value → null.value → NPE 발생!
```

---

## 해결 방법: 참조형 멤버 변수 초기화하기

멤버 변수 `data`가 null 상태이므로, 실제 Data 객체를 생성해 넣어야 함.

```java
public class NullMain4 {
    public static void main(String[] args) {
        BigData bigData = new BigData();
        bigData.data = new Data(); // 해결!

        System.out.println("bigData.data=" + bigData.data);
        System.out.println("bigData.data.value=" + bigData.data.value);
    }
}
```

### 실행 결과

```
bigData.data=ref.Data@x002
bigData.data.value=0
```

참조 흐름:

```
bigData → x001
x001.data → x002(Data 객체)
x002.value → 0
```

---

## 정리

* **NullPointerException은 null에 .(dot)을 찍을 때 발생한다.**
* 참조형 변수가 null인지 항상 확인해야 함.
* 멤버 변수는 자동 초기화되므로 참조형은 기본값이 null이라는 점에 주의.
* null 상태의 멤버 변수는 반드시 객체를 생성해 초깃값을 넣어줘야 함.

---

# 8. 문제와 풀이

## 상품 주문 시스템 개발 - 리팩토링 문제

### 문제.

기존에 `class1.ex.ProductOrderMain` 안에서 모든 로직을 한 번에 처리하던 코드를
**ref.ex 패키지로 옮기면서, 메서드를 활용해 리팩토링**하는 문제임.

목표는 크게 3가지였음.

1. `ProductOrder` 클래스로 상품 주문 정보(상품명, 가격, 수량)를 표현
2. 주문 생성을 담당하는 메서드 분리
3. 출력, 총합 계산 로직도 메서드로 분리

---

### ProductOrder 클래스

```java
package ref.ex;
public class ProductOrder {
    String productName;
    int price;
    int quantity;
}
```

* 상품 하나에 대한 **주문 정보만 담는 역할**만 하는 클래스임.
* 필드:

    * `productName` : 상품명
    * `price` : 가격
    * `quantity` : 수량

데이터 구조를 먼저 이렇게 정리해두니까, 그 위에 로직을 올리기가 편해짐.

---

### ProductOrderMain2 – 리팩토링된 메인 로직

```java
package ref.ex;

public class ProductOrderMain2 {

    public static void main(String[] args) {
        ProductOrder[] orders = {
                createOrder("두부", 2000, 2),
                createOrder("김치", 5000, 1),
                createOrder("콜라", 1500, 2)
        };

        printOrders(orders);

        int totalAmount = getTotalAmount(orders);
        System.out.println("총 결제 금액: " + totalAmount);
    }

    // 주문 생성 함수
    static ProductOrder createOrder(String productName, int price, int quantity) {
        ProductOrder order = new ProductOrder();
        order.productName = productName;
        order.price = price;
        order.quantity = quantity;
        return order;
    }

    // 주문 목록 출력
    static void printOrders(ProductOrder[] orders) {
        for (ProductOrder order : orders) {
            System.out.println("상품명: " + order.productName
                    + ", 가격: " + order.price
                    + ", 수량: " + order.quantity);
        }
    }

    // 총 가격 구하기
    static int getTotalAmount(ProductOrder[] orders) {
        int sum = 0;
        for (ProductOrder order : orders) {
            sum += order.price * order.quantity;
        }
        return sum;
    }
}
```

---

## 상품 주문 시스템 개발 - 사용자 입력 문제

### 문제.

이제는 **상품 정보와 주문 개수까지 사용자에게 직접 입력받는 형태**로 확장하는 문제였음.

요구 사항은 다음과 같았음.

* 주문 개수 입력
* 각 주문별로

    * 상품명
    * 가격
    * 수량
      을 입력
* 입력이 끝나면

    * 전체 주문을 출력
    * 총 결제 금액 출력

---

### ProductOrderMain3 – 사용자 입력 버전

```java
package ref.ex;

import java.util.Scanner;

public class ProductOrderMain3 {

    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            int orderCount = inputOrderCount(sc);

            ProductOrder[] orders = new ProductOrder[orderCount];

            inputOrders(sc, orders);

            printOrdersAndTotal(orders);
        }
    }

    // 주문 개수 입력
    static int inputOrderCount(Scanner sc) {
        System.out.print("입력할 주문의 개수를 입력하세요: ");
        String line = sc.nextLine();
        return Integer.parseInt(line);
    }

    // 각 주문 정보 입력
    static void inputOrders(Scanner sc, ProductOrder[] orders) {
        for (int i = 0; i < orders.length; i++) {
            System.out.println((i + 1) + "번째 주문 정보를 입력하세요.");

            System.out.print("상품명: ");
            String productName = sc.nextLine();

            System.out.print("가격 : ");
            int price = Integer.parseInt(sc.nextLine());

            System.out.print("수량 : ");
            int quantity = Integer.parseInt(sc.nextLine());

            ProductOrder order = new ProductOrder();
            order.productName = productName;
            order.price = price;
            order.quantity = quantity;

            orders[i] = order;
        }
    }

    // 주문 정보 + 총 결제 금액 출력
    static void printOrdersAndTotal(ProductOrder[] orders) {
        int sum = 0;

        for (ProductOrder order : orders) {
            System.out.println("상품명: " + order.productName
                    + ", 가격: " + order.price
                    + ", 수량: " + order.quantity);

            sum += order.price * order.quantity;
        }

        System.out.println("총 결제 금액: " + sum);
    }
}
```