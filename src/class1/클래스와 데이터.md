# 1. 클래스가 필요한 이유

자바 세상은 클래스와 객체로 이루어져 있음.  
그만큼 **클래스와 객체라는 개념은 자바에서 가장 중요한 핵심**임.  
하지만 처음 배우는 입장에서는 이 개념이 한 번에 와닿지 않는다.  
그래서 “왜 클래스가 필요한가?”를 실제 예시를 통해 단계적으로 알아봄.

---

## 문제: 학생 정보 출력 프로그램 만들기

두 명의 학생 정보를 출력하는 프로그램을 만들어보자.  
각 학생은 **이름, 나이, 성적**을 가지고 있음.

### 요구사항

1. 첫 번째 학생: 이름 `학생1`, 나이 `15`, 성적 `90`
2. 두 번째 학생: 이름 `학생2`, 나이 `16`, 성적 `80`
3. 출력 형식:
```

이름: [이름] 나이: [나이] 성적: [성적]

````
4. 변수를 사용해서 학생 정보를 저장하고 출력할 것.

---

##  변수만 사용한 버전 — `ClassStart1`

```java
package class1;

public class ClassStart1 {
 public static void main(String[] args) {
     String student1Name = "학생1";
     int student1Age = 15;
     int student1Grade = 90;

     String student2Name = "학생2";
     int student2Age = 16;
     int student2Grade = 80;

     System.out.println("이름:" + student1Name + " 나이:" + student1Age + " 성적:" + student1Grade);
     System.out.println("이름:" + student2Name + " 나이:" + student2Age + " 성적:" + student2Grade);
 }
}
````

**문제점**

* 학생이 늘어날 때마다 변수를 계속 추가해야 함
* 출력 코드도 계속 복사해야 함
* 데이터 관리가 매우 비효율적임

---

##  배열로 개선한 버전 — `ClassStart2`

```java
package class1;

public class ClassStart2 {
    public static void main(String[] args) {
        String[] studentNames = {"학생1", "학생2"};
        int[] studentAges = {15, 16};
        int[] studentGrades = {90, 80};

        for (int i = 0; i < studentNames.length; i++) {
            System.out.println("이름:" + studentNames[i] + " 나이:" + studentAges[i] + " 성적:" + studentGrades[i]);
        }
    }
}
```

**개선된 점**

* 학생이 추가되면 배열에 데이터만 추가하면 됨
* 출력 코드 수정 없이 자동으로 반영됨

---

###  학생 추가 전

```java
String[] studentNames = {"학생1", "학생2"};
int[] studentAges = {15, 16};
int[] studentGrades = {90, 80};
```

###  학생 추가 후

```java
String[] studentNames = {"학생1", "학생2", "학생3", "학생4", "학생5"};
int[] studentAges = {15, 16, 17, 10, 16};
int[] studentGrades = {90, 80, 100, 80, 50};
```

---

##  배열의 한계

배열 덕분에 관리가 쉬워졌지만, 여전히 **데이터가 분리되어 있음**.

* 이름, 나이, 성적이 서로 다른 배열에 저장됨
* 같은 학생의 정보라도 **인덱스 번호로만 연결**됨
* 학생 2의 정보를 삭제하려면 **세 개의 배열 모두 수정**해야 함

```java
String[] studentNames = {"학생1", "학생3", "학생4", "학생5"};
int[] studentAges = {15, 17, 10, 16};
int[] studentGrades = {90, 100, 80, 50};
```

---

## 클래스의 필요성

> 사람에게 친숙한 형태로 데이터를 묶어야 함.

학생의 이름, 나이, 성적을 **하나로 묶은 "학생"이라는 개념**으로 관리해야 함.

즉, “학생”이라는 객체 안에 이름, 나이, 성적이라는 속성이 들어있도록 만들어야 함.



이렇게 객체를 정의하기 위한 설계도가 바로 **클래스(Class)** 임.

---

## 정리

| 구분  | 방식            | 특징                   |
| --- | ------------- | -------------------- |
| 변수  | 각 데이터별로 변수 선언 | 학생 수가 늘어나면 코드 폭발     |
| 배열  | 데이터 집합으로 묶음   | 관리 쉬워지지만 속성이 분리됨     |
| 클래스 | 속성을 하나로 묶음    | 사람이 이해하기 쉽고 유지보수에 강함 |

# 2. 클래스 도입

이전에는 변수만을 이용해서 데이터를 따로따로 관리했다면,  
이번에는 **‘클래스(class)’**를 도입해서 문제를 해결해보자.

---

## 클래스란?

클래스는 **객체를 만들기 위한 설계도**임.  
예를 들어 학생이라는 개념을 코드로 표현하고 싶다면  
`Student`라는 클래스를 만들면 된다.

```java
package class1;

public class Student {
    String name;
    int age;
    int grade;
}
````

여기서 `Student` 클래스는
이름(`name`), 나이(`age`), 성적(`grade`)을 가지는 **학생 객체의 설계도**다.

---

## 멤버 변수 (Member Variable) / 필드 (Field)

* `name`, `age`, `grade`는 **클래스 내부에 정의된 변수**
* 이런 변수를 **멤버 변수(Member Variable)** 또는 **필드(Field)**라고 부름

| 용어                         | 의미                                    |
| -------------------------- | ------------------------------------- |
| **멤버 변수(Member Variable)** | 특정 클래스에 속한 변수                         |
| **필드(Field)**              | 데이터의 항목(컬럼). 데이터베이스나 엑셀에서도 같은 의미로 사용됨 |

즉, **자바에서 멤버 변수와 필드는 같은 뜻**이다.
클래스 내부에서 데이터를 저장하기 위한 변수를 의미함.

> 클래스 이름은 대문자로 시작하고 **낙타표기법(CamelCase)**을 사용하는 것이 관례
> 예: `Student`, `User`, `MemberService`

---

## 클래스 사용하기

이제 `Student` 클래스를 사용해서 실제 학생 데이터를 만들어보자.

```java
package class1;

public class ClassStart3 {
    public static void main(String[] args) {
        Student student1;
        student1 = new Student();
        student1.name = "학생1";
        student1.age = 15;
        student1.grade = 90;

        Student student2 = new Student();
        student2.name = "학생2";
        student2.age = 16;
        student2.grade = 80;

        System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
        System.out.println("이름:" + student2.name + " 나이:" + student2.age + " 성적:" + student2.grade);
    }
}
```

**실행 결과**

```
이름:학생1 나이:15 성적:90
이름:학생2 나이:16 성적:80
```

---

## 클래스와 사용자 정의 타입

타입(Type)은 데이터의 형태를 의미한다.
`int`는 정수 타입, `String`은 문자열 타입.

그렇다면 **학생**이라는 타입이 필요하다면?
→ `Student` 클래스를 만들어 직접 정의할 수 있음.

이렇게 사용자가 직접 만든 타입을 **사용자 정의 타입(User Defined Type)**이라 부른다.

즉,

* 클래스 = 설계도
* 객체(인스턴스) = 설계도로 찍어낸 실제 데이터

---

## 클래스, 객체, 인스턴스의 관계

| 용어                 | 의미                            |
| ------------------ | ----------------------------- |
| **클래스(Class)**     | 객체를 만들기 위한 설계도                |
| **객체(Object)**     | 메모리에 생성된 실제 실체                |
| **인스턴스(Instance)** | 클래스의 구체적인 사례 (객체와 같은 의미로 사용됨) |

예시

```java
Student student1 = new Student();
Student student2 = new Student();
```

→ `Student`는 설계도(클래스)
→ `student1`, `student2`는 실제 메모리에 만들어진 객체(인스턴스)

---

## 코드 분석

### 1) 변수 선언

```java
Student student1;
```

`Student` 타입의 변수를 선언한 것.
`int num;`이 정수를 담는 변수인 것처럼,
`Student student1;`은 학생 객체의 참조값을 담을 변수임.

---

### 2) 객체 생성

```java
student1 = new Student();
```

`new` 키워드는 **새로운 객체 생성**을 의미함.
즉, `Student` 설계도를 기반으로 실제 메모리에 객체를 하나 생성하는 것임.

메모리 어딘가에 `Student` 객체가 만들어지고,
그 위치(주소)에 해당하는 **참조값(reference value)**을 반환한다.

---

### 3) 참조값 보관

객체가 생성되면 자바는 메모리 어딘가에 객체를 만들고
그 위치를 나타내는 참조값(예: `x001`)을 반환한다.

```java
Student student1 = new Student(); // 1. 객체 생성
Student student1 = x001;          // 2. new Student()의 결과값 x001 반환
student1 = x001;                  // 3. student1이 참조값을 보관
```

이제 `student1`을 통해 `x001` 주소에 있는 객체를 참조할 수 있음.

---

## 참조값 확인하기

참조값은 실제로 확인할 수 있음.

```java
System.out.println(student1);
System.out.println(student2);
```

출력 예시:

```
class1.Student@7a81197d
class1.Student@2f2c9b19
```

* `@` 앞은 **패키지 + 클래스 정보**
* `@` 뒤의 **16진수 값**이 바로 객체의 **참조값**

참조값은 실제 메모리 주소는 아니지만,
각 객체를 구분하기 위한 고유한 식별자 역할을 함.

---

## 정리

| 개념                                    | 설명                          |
| ------------------------------------- | --------------------------- |
| **클래스(Class)**                        | 객체를 만들기 위한 설계도              |
| **객체(Object)**                        | 메모리에 실제로 만들어진 실체            |
| **인스턴스(Instance)**                    | 특정 클래스에서 생성된 객체 (객체와 같은 의미) |
| **필드(Field) / 멤버변수(Member Variable)** | 클래스 내부의 데이터 저장 공간           |
| **new 키워드**                           | 설계도를 기반으로 실제 객체를 생성         |
| **참조값(Reference Value)**              | 메모리에 생성된 객체의 주소 정보          |

# 3. 객체 사용

앞서 클래스(`Student`)를 통해 객체를 만들었다면,  
이제는 그 **객체에 접근하고 값을 읽거나 변경하는 방법**을 알아보자.

객체에 접근하려면 **`.` (dot 연산자)** 를 사용한다.  
즉, `객체참조변수.멤버변수` 형태로 접근하면 된다.

---

## 객체 값 대입 (쓰기)

```java
// 객체 값 대입
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;
````

`student1.name = "학생1";` 이라는 코드는 다음 과정을 거친다.

1. `student1`에 저장된 참조값(`x001`)을 읽음
2. 참조값이 가리키는 실제 객체(Student)의 `name` 멤버 변수에 접근
3. `"학생1"`이라는 값을 대입

```java
student1.name = "학생1";
// 내부적으로는 이렇게 동작
x001.name = "학생1";
```

---

###  실행 전후 메모리 구조

**실행 전**
![](https://velog.velcdn.com/images/hhyukk/post/e382a6a2-761c-4371-96ed-c79bf89313e3/image.png)

**실행 후**
![](https://velog.velcdn.com/images/hhyukk/post/be1de595-fdce-44b5-b7c4-1da02123e5bb/image.png)

* `student1.name` → `student1` 변수에 들어 있는 참조값을 통해 실제 객체 접근
* `x001.name = "학생1"` → `x001` 위치(객체)에 `"학생1"` 저장

즉, `student1`이 `x001` 참조값을 가지고 있으므로
`x001` 위치의 **Student 객체 내부 name 변수**에 데이터를 저장하는 것임.

---

## 객체 값 읽기 (읽기)

객체에 저장된 값을 가져올 때도 똑같이 `.` 연산자를 사용한다.

```java
// 1. 객체 값 읽기
System.out.println("이름: " + student1.name);

// 2. 내부적으로는 다음과 같은 과정
System.out.println("이름: " + x001.name);

// 3. 최종적으로 출력되는 값
System.out.println("이름: " + "학생1");
```

---

### 동작 원리

1. `student1` 변수에 저장된 참조값(`x001`)을 읽음
2. 해당 참조값을 통해 실제 객체(Student)에 접근
3. 객체 내부의 `name` 필드 값을 가져옴
4. `"학생1"`이 출력됨

---

### 메모리 구조 예시

**객체 값 읽기 과정**

![](https://velog.velcdn.com/images/hhyukk/post/4008e836-ff3a-4855-ac80-8d75a844111c/image.png)

**값을 읽어온 후 출력**

![](https://velog.velcdn.com/images/hhyukk/post/b06b9892-e09b-4578-9934-f4e4a4add6b2/image.png)

이처럼 `. (dot)` 연산자를 이용해
참조변수 → 실제 객체 → 멤버변수 순으로 접근하게 된다.

---

## 정리

| 개념                 | 설명                              |
| ------------------ | ------------------------------- |
| **`.` (dot 연산자)**  | 객체의 멤버(필드, 메서드)에 접근하기 위한 연산자    |
| **객체 값 대입**        | 참조값을 통해 실제 객체의 필드에 값을 저장        |
| **객체 값 읽기**        | 참조값을 통해 실제 객체의 필드 값을 읽어옴        |
| **참조변수(student1)** | 메모리에 생성된 객체(Student)의 위치 정보를 가짐 |
| **참조값(x001)**      | 실제 객체가 메모리에 저장된 주소(위치)          |

# 4. 클래스, 객체, 인스턴스 정리

객체지향 프로그래밍(OOP)을 이해하기 위해 꼭 구분해야 할 세 가지 개념이 있음  
바로 **클래스(Class)**, **객체(Object)**, **인스턴스(Instance)** 임.

---

## 클래스 (Class)

클래스는 **객체를 생성하기 위한 설계도 또는 틀**  
즉, “이런 속성과 기능을 가진 객체를 만들겠다”는 **청사진(blueprint)** 임.

예를 들어 `Student` 클래스를 정의하면  
그 안에는 `name`, `age`, `grade` 같은 **속성(필드)** 이 정의되어 있음.

```java
public class Student {
    String name;
    int age;
    int grade;
}
````

이 `Student`는 학생을 표현하기 위한 **설계도**일 뿐
아직 메모리에 존재하지 않음.

---

### 틀(붕어빵 비유)

* **클래스** → 붕어빵 틀
* **객체(인스턴스)** → 틀로 찍어낸 실제 붕어빵

붕어빵 틀 자체는 먹을 수 없지만,
그 틀을 이용해 팥 붕어빵을 여러 개 찍어낼 수 있음.
→ 이처럼 클래스는 “형태”를 정의할 뿐, “실체”는 아님.

---

###  설계도 비유

* **클래스** → 자동차 설계도
* **객체(인스턴스)** → 실제 조립된 테슬라 자동차

설계도는 개념적으로만 존재하고,
실제 도로 위에 달릴 수 있는 건 **객체(또는 인스턴스)** 임.

---

## 객체 (Object)

객체는 클래스의 설계도를 바탕으로 만들어진 **실제 실체(Real Entity)** 임.
즉, **클래스가 정의한 속성과 기능을 가진 존재**.

```java
Student student1 = new Student();
Student student2 = new Student();
```

* `student1`: 이름, 나이, 성적 등의 값을 가진 “학생1 객체”
* `student2`: 또 다른 속성을 가진 “학생2 객체”

두 객체는 **서로 독립적인 상태**를 가짐.
즉, `student1`의 점수를 바꿔도 `student2`에는 영향을 주지 않음.

---

## 인스턴스 (Instance)

**인스턴스**란, 특정 클래스에서 생성된 **객체를 가리키는 용어**임.


> “이 객체는 어떤 클래스의 인스턴스인가?”
> 라는 **관계에 초점을 맞춘 표현**임.


```java
Student student1 = new Student();
```

`student1`은 **`Student` 클래스의 인스턴스**임.

---

## 객체 vs 인스턴스

| 구분 | 객체(Object)      | 인스턴스(Instance)               |
| -- | --------------- | ---------------------------- |
| 의미 | 클래스에서 만들어진 실체   | 특정 클래스에서 생성된 객체              |
| 초점 | 존재 자체에 초점       | “어떤 클래스에서 왔는가”에 초점           |
| 예시 | `student1`은 객체다 | `student1`은 `Student`의 인스턴스다 |

즉, 모든 인스턴스는 객체이지만, 모든 객체를 인스턴스라고 하진 않는다.
→ 인스턴스는 **클래스와의 관계**를 강조할 때 사용하는 용어임.

---

## 정리

| 개념                 | 정의              | 비유                   |
| ------------------ | --------------- | -------------------- |
| **클래스(Class)**     | 객체를 만들기 위한 설계도  | 붕어빵 틀, 자동차 설계도       |
| **객체(Object)**     | 클래스에서 만들어진 실체   | 실제 붕어빵, 실제 자동차       |
| **인스턴스(Instance)** | 특정 클래스에서 생성된 객체 | “Student로부터 만들어진 객체” |

# 5. 배열 도입 — 시작

클래스와 객체를 통해 학생 데이터를 **구조적으로 표현**할 수 있게 되었음.  
하지만 여전히 학생이 늘어날 때마다  
출력문도 계속 늘려야 하는 **비효율적인 부분**이 존재함.

```java
System.out.println("이름:" + student1.name + " 나이:" + student1.age + ...);
System.out.println("이름:" + student2.name + " 나이:" + student2.age + ...);
````

새로운 학생이 추가될 때마다 이런 코드도 추가해야 함.
→ 이 문제를 해결하기 위해 **배열(Array)** 을 사용함.

---

## 배열이 필요한 이유

배열은 **같은 타입의 데이터를 연속된 공간에 저장**하고,
**인덱스(index)** 를 통해 쉽게 접근할 수 있도록 도와줌.

`Student`도 하나의 타입이므로,
여러 명의 학생을 한 번에 관리하기 위해 `Student` 타입 배열을 사용할 수 있음.

---

## Student 배열 도입

```java
package class1;

public class ClassStart4 {
    public static void main(String[] args) {
        Student student1 = new Student();
        student1.name = "학생1";
        student1.age = 15;
        student1.grade = 90;

        Student student2 = new Student();
        student2.name = "학생2";
        student2.age = 16;
        student2.grade = 80;

        // Student 타입의 배열 생성
        Student[] students = new Student[2];
        students[0] = student1;
        students[1] = student2;

        System.out.println("이름:" + students[0].name + " 나이:" + students[0].age + " 성적:" + students[0].grade);
        System.out.println("이름:" + students[1].name + " 나이:" + students[1].age + " 성적:" + students[1].grade);
    }
}
```

---

## 코드 분석

### 1. Student 인스턴스 생성

```java
Student student1 = new Student();
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

Student student2 = new Student();
student2.name = "학생2";
student2.age = 16;
student2.grade = 80;
```

* `Student` 클래스를 기반으로 두 개의 객체(`student1`, `student2`) 생성
* 각각의 인스턴스에 이름, 나이, 성적 값을 저장

![](https://velog.velcdn.com/images/hhyukk/post/4d832a32-ae09-4ab1-87a7-92766f582ecd/image.png)

---

### 2. Student 배열 생성

```java
Student[] students = new Student[2];
```

* `Student` 타입의 데이터를 **2개 보관할 수 있는 배열**을 생성
* 하지만 아직 객체는 연결되지 않음
* 배열 내부의 각 칸은 기본적으로 `null`로 초기화됨

![](https://velog.velcdn.com/images/hhyukk/post/8090b714-247a-4baf-962c-07a2f2cfd8b8/image.png)

---

### 3. 배열에 참조값 대입

```java
students[0] = student1;
students[1] = student2;
```

자바에서의 대입(=)은 **값 복사**임.
`student1`, `student2`에는 각각 참조값(`x001`, `x002`)이 들어있고,
이 값이 배열에 복사되어 저장된다.

```java
students[0] = x001;
students[1] = x002;
```

![](https://velog.velcdn.com/images/hhyukk/post/c0a392dd-32a5-4ee4-97d0-36d345060c7f/image.png)

이제 `students` 배열은 `x001`, `x002` 참조값을 가지며,
각각의 **학생 객체(인스턴스)** 에 접근할 수 있다.

![](https://velog.velcdn.com/images/hhyukk/post/af41e751-81f3-4dad-ba8b-3634d6537c2a/image.png)

>  **주의!**
> 변수에는 인스턴스 자체가 아닌 **인스턴스의 참조값**이 들어있다.
> 따라서 대입 시 객체 자체가 복사되는 게 아니라 **참조값만 복사됨.**

---

##  배열에 저장된 객체 사용

배열에 저장된 객체를 사용하려면
1.  배열에서 인덱스로 객체에 접근
2. `.` 연산자를 이용해 필드에 접근

---

### 학생1 예제

```java
System.out.println(students[0].name); // 1. 배열 접근
System.out.println(x005[0].name);     // 2. 배열의 0번 인덱스 접근
System.out.println(x001.name);        // 3. 참조값으로 실제 객체 접근
System.out.println("학생1");
```

---

### 학생2 예제

```java
System.out.println(students[1].name); // 1. 배열 접근
System.out.println(x005[1].name);     // 2. 배열의 1번 인덱스 접근
System.out.println(x002.name);        // 3. 참조값으로 객체 접근
System.out.println("학생2");
```

이 과정을 통해 배열을 이용해 여러 학생 객체를 효율적으로 관리할 수 있음.

---

## 정리

| 개념                 | 설명                           |
| ------------------ | ---------------------------- |
| **배열(Array)**      | 같은 타입의 데이터를 연속적으로 저장하는 자료 구조 |
| **참조값(Reference)** | 실제 객체의 메모리 주소를 가리키는 값        |
| **대입(=)**          | 변수에 저장된 **값을 복사**하는 연산       |
| **객체 배열**          | 객체의 참조값을 저장하는 배열             |


# 6. 배열 도입 — 리팩토링
## 기존의 문제점

학생이 늘어날 때마다 다음과 같은 출력문을 계속 추가해야 했음.

```java
System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
System.out.println("이름:" + student2.name + " 나이:" + student2.age + " 성적:" + student2.grade);
````

학생이 100명이라면 이런 코드가 100줄이 되어버림.
→ 배열과 반복문을 활용하면 이 문제를 깔끔하게 해결할 수 있음.

---

## ClassStart5 예제

```java
package class1;

public class ClassStart5 {
    public static void main(String[] args) {
        Student student1 = new Student();
        student1.name = "학생1";
        student1.age = 15;
        student1.grade = 90;

        Student student2 = new Student();
        student2.name = "학생2";
        student2.age = 16;
        student2.grade = 80;

        // 배열 선언
        Student[] students = new Student[]{student1, student2};

        // for문으로 반복 출력
        for (int i = 0; i < students.length; i++) {
            System.out.println("이름:" + students[i].name + " 나이:" +
                               students[i].age + " 성적:" + students[i].grade);
        }
    }
}
```

---

## 배열 선언 최적화

배열 생성 시 **생성과 동시에 값 대입**이 가능함.

기존 방식

```java
Student[] students = new Student[]{student1, student2};
```

최적화된 방식

```java
Student[] students = {student1, student2};
```

>  **직접 만든 클래스 타입(Student)** 도 일반 기본 타입(int, String 등)처럼 배열로 묶어 사용할 수 있음.

---

## for문 리팩토링

배열 덕분에 학생 수가 늘어나도 **for문 하나로 모든 학생을 출력**할 수 있게 됨.

```java
for (int i = 0; i < students.length; i++) {
    System.out.println("이름:" + students[i].name + 
                       " 나이:" + students[i].age + 
                       " 성적:" + students[i].grade);
}
```

---

## for문 개선 (변수 활용)

`students[i]`에 자주 접근해야 할 때는
반복문 내부에서 한 번 변수에 담아서 처리할 수도 있음.

```java
for (int i = 0; i < students.length; i++) {
    Student s = students[i];
    System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
}
```

이렇게 하면 코드가 한결 읽기 쉬워지고,
배열 요소에 대한 접근을 단순화할 수 있음.

---

## 향상된 for문 (Enhanced For Loop)

자바에서는 배열을 순회할 때 더 간결한 문법을 제공함.

```java
for (Student s : students) {
    System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" + s.grade);
}
```

* `Student s : students`
  → `students` 배열에서 하나씩 꺼내 `s` 변수에 담음
* 반복 횟수를 명시하지 않아도 됨
* **인덱스 없이 배열을 순회**할 수 있어 가장 깔끔한 방식

---

## 정리

| 개념             | 설명                                 |
| -------------- | ---------------------------------- |
| **배열 초기화**     | `{}`를 이용해 한 줄로 생성과 초기화를 동시에 수행 가능  |
| **기본 for문**    | 인덱스를 통해 직접 배열 요소에 접근               |
| **변수 활용 for문** | `Student s = students[i];`로 접근 단순화 |
| **향상된 for문**   | 인덱스 없이 간결하게 배열 순회 가능 (추천 방식)       |